\documentclass{article}
\usepackage[english]{babel}
\usepackage{verbatim}
\title{Knowledge Based Systems Solution Search A\_A1}
\author{Laura Khaze \& Erik Zeiske}
\date{10 April 2019}
\makeatletter
\newcommand{\problem}{Schatzsuche - das dreiteilige Medaillon}
\begin{document}
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
 
        \Huge
        \textbf{\@title}
 
        \vspace{0.5cm}
        \LARGE
        A documentation outlining the implementation of the problem search A
 
        \vspace{1.5cm}
 
        \textbf{\@author}
 
        \vfill
 
        %A documentation outlining the implementation of the problem\\
        Applied Computer Science
 
        %\vspace{0.8cm}
 
        %\Large
        INF 16A\\
        DHBW Stuttgart\\
        \@date
 
    \end{center}
\end{titlepage}
\tableofcontents
\newpage
\section{Problem Formulation} \label{problem_formulation}
The goal of the game \textit{\problem} is to compose a locket. The locket consists of three different components of type A, B and C. To compose the locket a player needs one component of each type. \\
The components of the locket are spread over the playground which consists of three different lands and some water areas. Within the playground a player can move either left, right, up or down as long as he does not enter a water area. Moreover it is not possible for the player to cross the boarder between land L1 and L2 if a component of type B is in his possession. \\
To solve the given problem, find all components and win the game the $A^*$ algorithm is implemented. \\

\section{Definitions}
In the following come terminologies are defined to create a common basis for this documentation.
\begin{description}
    \item{\textbf{Player}} The individual that moves around in order to find all components of the locket (For visual speaking purposes)
    \item{\textbf{Land}} There are three different lands. A land is either of type L1, L2 or L3.
    \item{\textbf{Field}} A field is described by an x y position. It is part of exactly one Land or is water. It can either be empty or contain exactly one component.
    \item{\textbf{Playground}} All fields arranged in a $m x n$ grid
    \item{\textbf{Components}} A component is either of type A,B or C. At least one copy ($n \geq \ $1) of each type is laying scattered on one field of the playground.
    \item{\textbf{State}\label{definition_state}}  Is a node of the graph to traverse with $A^*$ and is uniquely defined by the x and y position on the field and which components are already collected. 
    This means that a state can be represented as $S(x,y,A,B,C)$ where $x$, $y$ state the x and y coordinates of the associated field the player is currently on and $A, B, C$ weather he is holding the respective components. Thus $S(2,1,0,0,1)$ is the state on which the player is on field $(2,1)$ and holds only the component of Type C.
\end{description}

\section{Assumptions}
In order to implement a solution to the given problem \textit{\problem} it is necessary to make some assumptions about the details of the problem formulation. These assumption are:
\begin{enumerate}
    \item It is possible for a player to move through a field without picking up the component it is holding. 
    \item When a component was picked up it can not be laid down again.
    \item Since there is no added value it is not possible for a player to possess two components of the same type.
\end{enumerate}


\section{$A^*$ Algorithm}
To solve the problem formulation given in \ref{problem_formulation} with the $A^*$ algorithm the following points are decided and documented in the following.
\begin{comment}
\begin{itemize}
    \item Development of an graph
        \begin{itemize}
            \item What state does a node describe
            \item Set of terminating nodes
        \end{itemize}
    \item Distance function for the graph $k(S_1, S_2)$
    \item Estimation function $h(S)$
\end{itemize}
\end{comment}

\subsection{Graph Definition}
In order to define a graph first of all a node (i.e. a state) has to be defined: As the player can only be distinctly on a field it is only logical to associate the state to a field and a transition between the states to the movement between two fields. Also the players state should contain which components he has collected yet. See section \ref{definition_state} for an exact definition. As the player can move only right, left, up and down the possible changes from a movement point of view are:
% TODO add picture with x,y as coordinates and x+-1 / y+-1 respectively.
These movements might be blocked if the neighboring field is out site of the playground, the destination field is water or the player tries to cross the border between L1 and L2 (both directions).
\subsection{Distance function  $k(S_1, S_2)$}
Since a move between two fields takes one minute every movement state transition is associated with $k(S_1, S_2) = 1$.\\
As there is no downside to automatically picking up the component A and C, every move to a field containing one of these components will move the player to a state where the respective component is in their possession. In case of a field containing B the move to this field will not automatically pick up the component as it might block movement later on. Thus is is possible to explicitly pick up the component on such a field with no cost to the movement ($k(S(x,y,A,0,C), S(x,y,A,1,C)) = 0$).\\
All states of the form $S(x,y,1,1,1)$ are terminating states.

\subsection{Estimation function $h(S)$}
The goal of the implementation is to collect all components. Thus the shortest and best possibility to do so, is to go through all missing components taking the shortest path between them. \\
The shortest distance between two nodes can be determined by the Manhattan distance as the player can only move horizontally and vertically (without consideration of blocked movement due two water or the borders between two lands). Since the distance function equals one for each movement between two nodes ($k(S_1, S_2) = 1$) the Manhattan distance can be used as $h(S)$ to estimate the path between two components.
This way an optimistic $A^*$ algorithm is ensured, since $h(S) \geq \ h^*(S)$.

 For example if the player is already holding A and B the estimation has to take the Manhattan distance to all C components and return the minimum of these distances. Respectfully if no components are held by the player all possible orders of going through the components have to be associated with there respective distances and the shortest is the estimate for the state. As the distance between the components is not changing the estimation from the component fields can be cached (This is further explained in the implementation part). %TODO add reference


\section{Implementation}
The implementation of the $A^*$ algorithm is realized in C++
\subsection{Input and Output}
The implementation requires six inputs and returns the best route as an output.\\
Example input: \textit{20 20 "data/spielfeld\_1.csv" "data/S11.txt" 0 0}\\
Example output: \textit{(0,0) - (0,1)}
\begin{description}
    \item{\textbf{Input playground size}} The first two input parameters \textit{m n} define the size of the playground $m x n$ grid width, height
    \item{\textbf{Input playground}} The third input parameter is a csv file with the playground itself. Thereby each land type is represented by one number: L1 is represented by a 1, L2 by 2, L3 by 3 and water by 0. If the given playground is bigger than the size given by the parameters \textit{m n} only size \textit{m n} is realized.
    \item{\textbf{Input components}} The fourth input parameter is a text file which contains the coordinates of the components in the format \textit{Type;X;Y}.
    \item{\textbf{Input start position player}} The fifth and sixth parameter set the start coordinates of the player. If the start position of the player is outside of the playground or on a water field an error message is thrown.
    \item{\textbf{Output route}} The program returns the best route to collect one component of each type as an output. The single fields (x,y coordinates) of the route are printed in the correct order.
\end{description}

\subsection{Program Structure}
Since the source code of the program is well annotated only some main ideas and strategies are explained in this section.\\
The $A^*$ algorithm is implemented with of four different classes: Component, Playground, PriorityQueue and State as well as the namespace helper. 

\begin{description}
    \item[Component] Every instance of this class has a type (A, B or C) saved as a bit. A is represented by 001, B by 010 and C by 100. Due to the bit representation it is possible to use a bit mask and use different bit shifting operations. Moreover a caching table is saved within this class, see \textit{\ref{estimation_caching_tables} Estimation Caching Tables}.
    \item[Playground]
    \item[PriorityQueue]
    \item[State]
    \item[Helper]
\end{description}

\subsection{Abstraktion, graph vs spielfeld}
A* und h nur auf graph


\subsection{Klassen}
Artifact

playground
erzeugt durch einlesen der files, basic object
calculate path --> hauptfunction
getEstimate, unser H
bitmaske artifact
artifact, bitmaske 

priority queue
-> heap: choice because its easy, brauchen nur kleinstes element, alles andere overkill
-> kleinestes Element
-> inklusive update möglichkeit wenn neuer state "besser", nur wenn g kleiner ist, nach h+g sortiert

state
namespace: helper
helper functinos die zu keinem objekt gehören



\subsection{Estimation Caching tables} \label{estimation_caching_tables}
Each instance of the class component saves its own caching table. In this table the estimated distance from the specific component to collect all other components is saved. This example is a caching table of a component A:
\begin{center}
\begin{tabular}{ |c|c|c|c|c|c| } 
 \hline
 %\multicolumn{3}{|c|}{CBA}
 C & B & A & $h(S)$ & level \\ 
 \hline
 0 & 0 & 0 & 13 & 0 \\ 
 0 & 0 & 1 & 13 & 0 \\ 
 0 & 1 & 0 & 5 & 1 \\ 
 0 & 1 & 1 & 5 & 1 \\ 
 1 & 0 & 0 & 9 & 1 \\ 
 1 & 0 & 1 & 9 & 1 \\ 
 1 & 1 & 0 & 0 & 2 \\ 
 1 & 1 & 1 & 0 & 2 \\ 
 \hline
\end{tabular}
%\caption{Caching table of a component A}
\label{tab:caching table}
\end{center}
If the component is already in the possession of the player when he enters the field a 1 is saved in the table otherwise a 0. 
The caching table is filled and saved within the component since, due to the assumption 2, the table will not change. 
The level is the number of components which are already in the possession of the player. 
Since the Manhattan distance is used as an optimistic estimation function the triangle equation is true. This enables the calculation of $h(S)$ based on the $h(S)$ value of the next higher level.


\section{Testing}
1xn über b und zurück
kein Weg, terminiert?
normales beispiel 

\section{Evaluation and possible Improvement}
kürzerer Weg wäre möglich, wenn component wieder abgelegt werden kann --> overkill

\end{document}